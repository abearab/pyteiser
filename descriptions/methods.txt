
pyTEISER
pyTEISER identifies RNA structural motifs that are informative of changes in gene expression, RNA stability or other quantitative transcriptomic measures.
Seed definition: the base unit describing instances of a secondary structure element is called a seed. A seed is an element of length N that has a pre-defined secondary structure (generally, stem-loop) and a degenerate sequence. An example seed would have a secondary structure of ‘<<<<......>>>>’ and a sequence of ‘AAUNNGNGNUNAUU’, where N can be any nucleotide. For any given seed, any sequence A of length N can be unambiguously identified as a match - in case the sequence A is correctly described by seed's degenerate sequence and it can potentially fold into the seed's secondary structure, forming only canonical base pairs or a G-U wobble base pair. If any of these criteria are not met, sequence A is considered a non-match. This definition of seeds is inspired by the concept of context-free grammars, which was implemented in the earlier versions of TEISER. This framework allows for fast scanning of any sequence of length M for matches with a rolling window of length N. In theory, in the worst-case scenario the scanning algorithm takes quadratic time, in practice all the possible analyzed seeds are short (less than 17 nt) long so the algorithm works in O(C×M) = O(M).

Seed occurrence profile: as an input, pyTEISER uses a set of K sequences together with corresponding transcriptomic measurements. For each of these sequences, we can determine unambiguously if this sequence contains any matches to a given seed. This search can be either performed based solely on primary sequence or it can incorporate secondary structure information, such as RNA SHAPE data, DMS-seq data, or in silico RNA folding data. The result of this search is then represented as a binary vector of length K. Each element is set to "1" if the corresponding sequence has a match to the given seed or "0" if it doesn't. The resulting binary vector is called a "seed profile"; it represents which sequences can potentially contain a match to sequence and structural rules described by a given seed.

Structural element profiles: A given structural elements is best viewed as a collection of seeds that together capture the required heterogeneity in its form. This is akin to the relationship of a set of k-mers forming a degenerate sequence motif. In pyTEISER, we use the term "motif" to describe a set of seeds that have similar occurrence profiles and likely capture different facets of the same structural element. Formally, a motif is a set of seeds, and its occurrence profile is an overlap of all of the motif's seeds occurrence profiles (OR rule). 

Generating seeds: pyTEISER generates a comprehensive set of short seeds of stem-loop structures that meet several criteria regarding their stem length, loop length and information content. The information content of the seed X is defined as the negative logarithm of P(X), where P(X) is the probability that a random sequence of the same length matches the seed X. The default boundaries for seed creation are: stem length between 4 and 7 nucleotides, loop length between 4 and 9 nucleotides, number of non-degenerate nucleotides in seed's sequence between 4 and 6, and information content between 14 and 20 bits. These criteria result in ~70 million seeds.

Sequence scanning: each generated seed is scanned across the provided sequences, resulting in the generation of a seed occurrence profile. In pyTEISER, however, Additional criteria can be included to make the seed profiles more specific. First, information provided by in silico folding algorithms can be used to exclude the potential seed matches that are unlikely to fold in the predicted way. ViennaRNA software is used to predict folding for the RNA sequence in a window flanking the seed match. Those matches for which the predicted folds differ from seed's secondary structure are excluded. Similarly, RNA SHAPE data, when available, can be used to guide selection of matches that are specific for a certain biological condition. A GMM-HMM is used to predict the base pairing of each nucleotide in the sequence based on experimental measurements. If the predicted state of nucleotides (paired vs. unpaired) in the matched sequence differ from the seed's secondary structure with high confidence, the corresponding matches are excluded as well.

Calculation of mutual information values: each seed's occurrence profile is tested to assess whether it is informative of the input transcriptomic measurements. To capture such dependency, we use Mutual Information (MI). Since calculation of MI requires both input vectors to be discrete, we discretize the provided continuous genome-wide measurements (for example, expression values, percent-spliced-in values, etc) in a pre-defined number of equal frequency bins.

Randomization-based statistical testing: pyTEISER runs several non-parametric statistical tests to determine which seeds are significantly informative of expression changes and which ones are not. The tests include (i) a permutation-based estimation of p-value with a null-hypothesis of the expected MI value for a given seed not being different from the expected MI value of a random occurrence profile with the same number of matches and (ii) a permutation-based estimation of the z-score for the MI value for a given seed. All the seeds are sorted by their MI values and a greedy search algorithm identifies the threshold MI value; all the seeds whose MI values exceed the threshold are considered "passed". The threshold is defined as a value of MI at which 9 out of 10 first seeds below the threshold do not satisfy the threshold for p-value and/or z-score. 

Defining structural elements: the initial random sampling of seeds generated by pyTEISER may be functionally redundant. In other words, several seeds can be very similar to each other and match the same or similar sequences. Such redundant groups of seeds are clustered into structural elements or motifs. Each seed (Q) is compared to a set of seeds (R) considered before to decide if this seed should form its own motif or if it should be added to one of the existing motifs. For this, we calculate conditional mutual information of occurrence profile of Q with the input data given the occurrence profile of R. We then divide this value by the mutual information of the occurrence profile of Q and the occurrence profile of R. If the resulting value is higher than an indicated threshold, we conclude that Q and R are two representations of the same underlying element.

Seed optimization: pyTEISER aims to find and describe the structural element(s) that would best explain transcriptomic measurements. Since seeds provide a coarse-grained sampling of the search space, any seed that passes the statistical tests may be suboptimal. Therefore, for each structural element, a representative seed is selected for further optimization in a two-stage algorithm. The first stage involves modification of each position of the seed. Modifications include replacing the original nucleotide with all possible degenerate nucleotides (15 in total), or changing the base pairing state of the given position. Positions of the seed are modified in a random order to avoid biases. For the seeds resulting from such modification process the occurrence profile is built, and then mutual information of the occurrence profile with the genome-wide measure of interest is calculated. The seed with the best mutual information value is retained. The second stage involves seed elongation. A seed is elongated on both ends using a greedy search to maximize MI values. At each step of elongation all the possible degenerate nucleotides and both base pairing states for the new position are evaluated. Therefore, the optimized seed is guaranteed to have the mutual information value not less than that of the initial seed.

Robustness test: in order to test if the optimized seeds or motifs are robust to changes of the input data, the statistical tests are repeated with down-sampled input data. By default, the tested seed is required to pass  p-value and z-score thresholds for at least 6 trials out of 10, where in each trial only 2/3 of the input data is retained. 

Implementation and availability: pyTEISER is written in Python 3.7 and requires numba compiler for efficient performance. The source code is available at https://github.com/goodarzilab/pyteiser


